esphome:
  name: ohmpilot
  friendly_name: Ohmpilot

esp32:
  board: esp32-s3-devkitc-1
  framework:
    type: esp-idf

# Enable logging
logger:

# Enable Home Assistant API
api:
  encryption:
    key: ""

ota:
  - platform: esphome
    password: ""

#wifi:
#  ssid: !secret wifi_ssid
#  password: !secret wifi_password
#  manual_ip:
#    static_ip: 192.168.1.22
#    gateway: 192.168.1.1
#    subnet: 255.255.255.0
#    dns1: 8.8.8.8
#    dns2: 8.8.4.4

ethernet:
  type: W5500
  clk_pin: GPIO42
  mosi_pin: GPIO43
  miso_pin: GPIO44
  cs_pin: GPIO41
  interrupt_pin: GPIO2
  reset_pin: GPIO1
  manual_ip:
    static_ip: 192.168.1.22
    gateway: 192.168.1.1
    subnet: 255.255.255.0
    dns1: 8.8.8.8
    dns2: 8.8.4.4

web_server:
  port: 80

# Sun — szükséges a napkelte / napnyugta ellenőrzéshez
sun:
  latitude: 46.32235
  longitude: 20.49440
  id: sun_main

time:
  - platform: sntp
    servers:
      - 0.hu.pool.ntp.org
      - 1.hu.pool.ntp.org
    id: sntp_time
    on_time:
      - seconds: /30
        then:
          - lambda: |-
              bool value_ev = id(futas_engedelyezett_ev).state;
              id(futas_engedelyezett_ev).publish_state(value_ev);
              bool value_nyar = id(futas_engedelyezett_nyar).state;
              id(futas_engedelyezett_nyar).publish_state(value_nyar);

uart:
  - id: mod_bus
    baud_rate: 4800
    parity: NONE 
    stop_bits: 1
    debug:
      direction: BOTH
      dummy_receiver: true
      after:
        timeout: 10ms
    tx_pin: 7
    rx_pin: 15

modbus:  
  id: modbus1

modbus_controller:  
  - id: omero
    address: 0x0003
    modbus_id: modbus1
    setup_priority: -10
    update_interval: 1500ms
    command_throttle: 500ms

# PID működéséhez szükséges globális változók definiálása
globals:
    # Az aktuális hibát (eltérés a kívánt érték – „setpoint” – és a mért érték – „measurement” – között).
    # Ez az alapja a PID-számításnak
  - id: pid_error_l1
    type: float
    initial_value: '0'

    # Az összegzett hibát – vagyis az időben felhalmozott hibák összegét.
    # A PID „I” (integráló) komponense ezt használja, hogy figyelembe vegye a tartós eltéréseket,
    # és fokozatosan rásegítsen, ha a vezérlés nem éri el a kívánt értéket.
  - id: pid_integral_l1
    type: float
    initial_value: '0'

    # Az előző ciklusban mért hibát.
    # Ebből számolható ki a derivált (változási sebesség) – vagyis a „D” komponens:
    # derivative = current_error - prev_error
    #Ez segít tompítani a hirtelen változásokat („belengéseket”).
  - id: pid_prev_error_l1
    type: float
    initial_value: '0'

    # A három komponensből áll össze a PID-kimenet:
    #  output = kp * error + ki * integral + kd * derivative

    # Majd ezt az output értéket használjuk a PWM szint beállítására, például:
    # id(pwm_output1).set_level(output);

  - id: pid_error_l2
    type: float
    initial_value: '0'
  - id: pid_integral_l2
    type: float
    initial_value: '0'
  - id: pid_prev_error_l2
    type: float
    initial_value: '0'

  - id: pid_error_l3
    type: float
    initial_value: '0'
  - id: pid_integral_l3
    type: float
    initial_value: '0'
  - id: pid_prev_error_l3
    type: float
    initial_value: '0'

  - id: pid_error_3f
    type: float
    initial_value: '0.0'
  - id: pid_integral_3f
    type: float
    initial_value: '0.0'
  - id: pid_prev_error_3f
    type: float
    initial_value: '0.0'

  # Fűtőszál teljesítménye:
  - id: futoszal_teljesitmeny_3f
    type: float
    initial_value: '3.2'  # Állítsd be a valódi értéket! [kW]

  - id: futoszal_teljesitmeny_1f
    type: float
    initial_value: '1.06'  # Állítsd be a valódi értéket! [kW]

 # Globális változók mk2 vezérléséhez
  - id: pwm_l1
    type: float
    initial_value: '0.0'

  - id: pwm_l2
    type: float
    initial_value: '0.0'

  - id: pwm_l3
    type: float
    initial_value: '0.0'

datetime:
  - platform: template
    id: futes_kezdete
    name: "Fűtési időszak kezdete"
    type: date
    initial_value: "2025-10-15"
    optimistic: true

  - platform: template
    id: futes_vege
    name: "Fűtési időszak vége"
    type: date
    initial_value: "2025-03-15"
    optimistic: true

  - platform: template
    id: futes_ido_kezd
    name: "Fűtési idő kezdete"
    type: time
    initial_value: "13:00:00"
    optimistic: true

button:
  - platform: restart
    name: "Restart"

number:
  - platform: template
    id: celt
    name: "Célhőmérséklet"
    unit_of_measurement: "°C"
    device_class: temperature
    max_value: 65.0
    min_value: 30.0
    step: 0.5
    optimistic: true
    initial_value: 55.0
    mode: BOX
    on_value: 
      - then:
        - script.execute: power

  - platform: template
    id: maxt
    name: "Maximális hőmérséklet"
    unit_of_measurement: "°C"
    device_class: temperature
    max_value: 75.0
    min_value: 30.0
    step: 0.5
    optimistic: true
    initial_value: 65.0
    mode: BOX
    on_value: 
      - then:
        - script.execute: power

  - platform: template
    id: kcel
    name: "Alapjel"
    unit_of_measurement: "%"
    max_value: 100.0
    min_value: 0.0
    step: 1
    optimistic: true
    initial_value: 0.0
    on_value: 
      - then:
        - script.execute: power

select:
- platform: template
  id: mukodes
  name: "Működés"
  options:
    - "Auto"
    - "Kézi"
  initial_option: "Auto"
  optimistic: True
  set_action:
      then:
        - script.execute: power

- platform: template
  id: mukodes_fazis
  name: "Fázisválasztó"
  options:
    - "Egy"
    - "Három"
  initial_option: "Három"
  optimistic: True
  set_action:
      then:
        - script.execute: power

sensor:
#  - platform: wifi_signal
#    name: "WiFi Signal Sensor"
#    update_interval: 60s

  - platform: modbus_controller
    modbus_controller_id: omero
    id: opt
    name: "Pillanatnyi teljesítmény"
    address: 0x5012
    state_class: measurement
    device_class: power
    unit_of_measurement: "kW" 
    register_type: holding
    value_type: FP32
    accuracy_decimals: 2

  - platform: total_daily_energy
    name: 'Napi fogyasztás'
    power_id: opt
    unit_of_measurement: 'kWh'
    state_class: total_increasing
    device_class: energy
    accuracy_decimals: 3

  - platform: modbus_controller
    modbus_controller_id: omero
    id: opt_l1
    name: "Pillanatnyi teljesítmény L1"
    address: 0x5014
    state_class: measurement
    device_class: power
    unit_of_measurement: "kW" 
    register_type: holding
    value_type: FP32
    accuracy_decimals: 2

  - platform: modbus_controller
    modbus_controller_id: omero
    id: opt_l2
    name: "Pillanatnyi teljesítmény L2"
    address: 0x5016
    state_class: measurement
    device_class: power
    unit_of_measurement: "kW" 
    register_type: holding
    value_type: FP32
    accuracy_decimals: 2

  - platform: modbus_controller
    modbus_controller_id: omero
    id: opt_l3
    name: "Pillanatnyi teljesítmény L3"
    address: 0x5018
    state_class: measurement
    device_class: power
    unit_of_measurement: "kW" 
    register_type: holding
    value_type: FP32
    accuracy_decimals: 2

  - platform: modbus_controller
    modbus_controller_id: omero
    id: ove
    name: "Hatásos villamos energia"
    address: 0x600C
    state_class: total_increasing
    device_class: energy
    unit_of_measurement: "kWh" 
    register_type: holding
    value_type: FP32
    accuracy_decimals: 2
    internal: True

  - platform: template
    id: ovf
    name: "Villamos fogyasztás"
    state_class: total_increasing
    device_class: energy
    unit_of_measurement: "kWh"
    lambda: |-
      return id(ove).state - 284.76; // A fogyasztásmérő korábbi fogyasztása, ha nem 0-ról indult a mérés.
  
  - platform: homeassistant
    entity_id: sensor.p1_meter_5c2faf10f87a_aktiv_teljesitmeny_1_fazis
    id: fmw1
    name: "Fogyasztásmérő L1"
    device_class: power
    unit_of_measurement: "W"
    on_value: 
      - then:
        - script.execute: power

  - platform: homeassistant
    entity_id: sensor.p1_meter_5c2faf10f87a_aktiv_teljesitmeny_2_fazis
    id: fmw2
    name: "Fogyasztásmérő L2"
    device_class: power
    unit_of_measurement: "W"
    on_value: 
      - then:
        - script.execute: power

  - platform: homeassistant
    entity_id: sensor.p1_meter_5c2faf10f87a_aktiv_teljesitmeny_3_fazis
    id: fmw3
    name: "Fogyasztásmérő L3"
    device_class: power
    unit_of_measurement: "W"
    on_value: 
      - then:
        - script.execute: power   

  - platform: homeassistant
    entity_id: sensor.p1_meter_5c2faf10f87a_aktiv_teljesitmeny
    id: fmw
    name: "Fogyasztásmérő"
    device_class: power
    unit_of_measurement: "W"
    on_value: 
      - then:
        - script.execute: power 

  - platform: homeassistant
    entity_id: sensor.bsb_lan_hmv_homerseklet_b3
    id: hmvh
    name: "HMV tartály hőmérséklet"
    device_class: temperature
    unit_of_measurement: "°C"
    on_value: 
      - then:
        - script.execute: power

  - platform: homeassistant
    entity_id: sensor.fennmarado_villamos_energia
    id: fve
    name: "Fennmaradó villamos energia"
    device_class: energy
    unit_of_measurement: "kWh"

binary_sensor:
  - platform: status
    id: st
    name: "ESP Kapcsolatban van"

  - platform: gpio
    name: "MK1"
    id: mk1_input
    pin:
      number: 16
      inverted: true
    on_state: 
      - then:
        - script.execute: power

  - platform: gpio
    name: "Engedélyező kapcsoló"
    id: en_switch
    pin:
      number: 17
      inverted: true
    on_state: 
      - then:
        - script.execute: power

  # Engedélyezés ősz-tavasz: 09.15 -> 12.31 és 01.01 -> 05.15, napközben, fennmaradó villamos energia > 0
  - platform: template
    name: "Fűtés engedélyezett (őszi–tavaszi)"
    id: futas_engedelyezett_ev
    lambda: |-
      // Fennmaradó energia
      float energy = id(fve).state;
      if (energy <= 0.0) return false;

      // Aktuális dátum
      auto now = id(sntp_time).now();
      if (!now.is_valid()) return false;
      int m = now.month;
      int d = now.day_of_month;

      // Beállított kezdő dátum (téli időszak kezdete)
      int sm = id(futes_kezdete).month;
      int sd = id(futes_kezdete).day;

      // Beállított záró dátum (téli időszak vége)
      int em = id(futes_vege).month;
      int ed = id(futes_vege).day;

      bool in_range = false;

      // Ellenőrizzük, hogy átnyúlik-e évfordulón (pl. 09.15 → 05.15)
      bool crosses_year = (sm > em) || (sm == em && sd > ed);

      if (crosses_year) {
        // Példa: 09.15 → 12.31 ÉS 01.01 → 05.15
        if ((m > sm || (m == sm && d >= sd)) ||
            (m < em || (m == em && d <= ed))) {
          in_range = true;
        }
      } else {
        // Nem lépi át az év végét
        if ((m > sm || (m == sm && d >= sd)) &&
            (m < em || (m == em && d <= ed))) {
          in_range = true;
        }
      }

      if (!in_range) return false;

      // Kezdő időpont (óra:perc)
      int sh = id(futes_ido_kezd).hour;
      int smi = id(futes_ido_kezd).minute;

      if (now.hour < sh || (now.hour == sh && now.minute < smi))
        return false;

      // Napközben legyen
      if (!id(sun_main).is_above_horizon()) return false;

      return true;

  # Engedélyezés nyár: 05.15 -> 09.15 között, csak ha a fennmaradó villamos energia > 0
  - platform: template
    name: "Fűtés engedélyezett (nyári)"
    id: futas_engedelyezett_nyar
    lambda: |-
      // Fennmaradó energia
      float energy = id(fve).state;
      if (energy <= 0.0) return false;

      // Aktuális dátum
      auto now = id(sntp_time).now();
      if (!now.is_valid()) return false;
      int m = now.month;
      int d = now.day_of_month;

      // Nyár kezdete = téli időszak vége (pl. 05.15)
      int sm = id(futes_vege).month;
      int sd = id(futes_vege).day;

      // Nyár vége = téli időszak kezdete (pl. 09.15)
      int em = id(futes_kezdete).month;
      int ed = id(futes_kezdete).day;

      // Dátum tartomány ellenőrzése
      bool in_range = false;
      if ((m > sm || (m == sm && d >= sd)) &&
          (m < em || (m == em && d <= ed))) {
        in_range = true;
      }

      return in_range;

script:
  - id: power
    mode: single
    then:
      - lambda: |-
          ESP_LOGI("custom", "power script fut");

          bool ev = id(futas_engedelyezett_ev).state;
          bool nyar = id(futas_engedelyezett_nyar).state;
          bool mk1 = id(mk1_input).state;
          bool en = id(en_switch).state;

          const char* mode = id(mukodes).current_option();         // Auto / Manual
          const char* fazis = id(mukodes_fazis).current_option();  // Egy / Három

          bool felt = (id(hmvh).state < id(celt).state &&
                       id(maxt).state > id(hmvh).state &&
                       mk1 && 
                       en_switch);

          if (!felt) {
            // univerzális lekapcsolás
            id(pwm_output1).set_level(0);
            id(pwm_output2).set_level(0);
            id(pwm_output3).set_level(0);
            id(pwm_l1) = 0.0;
            id(pwm_l2) = 0.0;
            id(pwm_l3) = 0.0;
            id(pid_integral_l1) = 0;
            id(pid_integral_l2) = 0;
            id(pid_integral_l3) = 0;
            id(pid_integral_3f) = 0;
            ESP_LOGD("custom", "Nincs fűtési feltétel – minden PWM=0");
            return;
          }

          // ------------------------------------------------------------------
          //                           TÉLI ÜZEM
          // ------------------------------------------------------------------
          if (ev && strcmp(mode, "Auto") == 0) {

            // ----- 1 fázis -----
            if (strcmp(fazis, "Egy") == 0) {
              id(pwm_output1).set_level(0.95);
              id(pwm_output2).set_level(0.95);
              id(pwm_output3).set_level(0.95);
              id(pwm_l2) = 0.95;
              id(pwm_l1) = 0.95;
              id(pwm_l3) = 0.95;
              ESP_LOGI("custom", "Téli 1F override – 95%% PWM");
              return;
            }

            // ----- 3 fázis -----
            if (strcmp(fazis, "Három") == 0) {
              id(pwm_output1).set_level(0.95);
              id(pwm_output2).set_level(0.95);
              id(pwm_output3).set_level(0.95);
              id(pwm_l1) = 0.95;
              id(pwm_l2) = 0.95;
              id(pwm_l3) = 0.95;
              ESP_LOGI("custom", "Téli 3F override – 95%% PWM minden fázison");
              return;
            }
          }

          // ------------------------------------------------------------------
          //                         NYÁRI PID (AUTO)
          // ------------------------------------------------------------------
          if (nyar && strcmp(mode, "Auto") == 0) {

            // ----- 1 fázis -----
            if (strcmp(fazis, "Egy") == 0) {

              float setpoint = -100.0;
              float measurement1 = id(fmw1).state;
              float measurement2 = id(fmw2).state;
              float measurement3 = id(fmw3).state;
              float error1 = setpoint - measurement1;
              float error2 = setpoint - measurement2;
              float error3 = setpoint - measurement3;

              float kp = 0.5, ki = 0.01, kd = 0.1;

              id(pid_integral_l1) += error1;
              id(pid_integral_l2) += error2;
              id(pid_integral_l3) += error3;
              id(pid_integral_l1) = fmax(fmin(id(pid_integral_l1), 1000.0), -1000.0);
              id(pid_integral_l2) = fmax(fmin(id(pid_integral_l2), 1000.0), -1000.0);
              id(pid_integral_l3) = fmax(fmin(id(pid_integral_l3), 1000.0), -1000.0);
              float derivative1 = error1 - id(pid_prev_error_l1);
              float derivative2 = error2 - id(pid_prev_error_l2);
              float derivative3 = error3 - id(pid_prev_error_l3);
              id(pid_prev_error_l1) = error1;
              id(pid_prev_error_l2) = error2;
              id(pid_prev_error_l3) = error3;

              float output1 = kp*error1 + ki*id(pid_integral_l1) + kd*derivative1;
              float output2 = kp*error2 + ki*id(pid_integral_l2) + kd*derivative2;
              float output3 = kp*error3 + ki*id(pid_integral_l3) + kd*derivative3;
              float clipped1 = fmax(fmin(output1 / id(futoszal_teljesitmeny_1f), 1.0), 0.0);
              float clipped2 = fmax(fmin(output2 / id(futoszal_teljesitmeny_1f), 1.0), 0.0);
              float clipped3 = fmax(fmin(output3 / id(futoszal_teljesitmeny_1f), 1.0), 0.0);

              id(pwm_output1).set_level(clipped1);
              id(pwm_output2).set_level(clipped2);
              id(pwm_output3).set_level(clipped3);
              id(pwm_l1) = clipped1;
              id(pwm_l2) = clipped2;
              id(pwm_l3) = clipped3;
              ESP_LOGI("custom", "PID 1F | pwm=%.4f", clipped1);
              ESP_LOGI("custom", "PID 1F | pwm=%.4f", clipped2);
              ESP_LOGI("custom", "PID 1F | pwm=%.4f", clipped3);
              return;
            }

            // ----- 3 fázis -----
            if (strcmp(fazis, "Három") == 0) {

              float setpoint = -100.0;
              float measurement = id(fmw).state;
              float error = setpoint - measurement;

              float kp = 0.5, ki = 0.01, kd = 0.1;

              id(pid_integral_3f) += error;
              id(pid_integral_3f) = fmax(fmin(id(pid_integral_3f), 3000.0), -3000.0);
              float derivative = error - id(pid_prev_error_3f);
              id(pid_prev_error_3f) = error;

              float output = kp*error + ki*id(pid_integral_3f) + kd*derivative;
              float clipped = fmax(fmin(output / id(futoszal_teljesitmeny_3f), 1.0), 0.0);

              id(pwm_output1).set_level(clipped);
              id(pwm_output2).set_level(clipped);
              id(pwm_output3).set_level(clipped);
              id(pwm_l1) = clipped;
              id(pwm_l2) = clipped;
              id(pwm_l3) = clipped;

              ESP_LOGI("custom", "PID 3F | pwm=%.4f", clipped);
              return;
            }
          }

          // ------------------------------------------------------------------
          //                             KÉZI MÓD
          // ------------------------------------------------------------------
          if (strcmp(mode, "Auto") != 0) {

            float pwm = id(kcel).state / 100.0;

            if (strcmp(fazis, "Egy") == 0) {
              id(pwm_output1).set_level(pwm);
              id(pwm_output2).set_level(pwm);
              id(pwm_output3).set_level(pwm);
              id(pwm_l1) = pwm;
              id(pwm_l2) = pwm;
              id(pwm_l3) = pwm;
              ESP_LOGI("custom", "Kézi 1F pwm=%.2f", pwm);
            }

            if (strcmp(fazis, "Három") == 0) {
              id(pwm_output1).set_level(pwm);
              id(pwm_output2).set_level(pwm);
              id(pwm_output3).set_level(pwm);
              id(pwm_l1) = pwm;
              id(pwm_l2) = pwm;
              id(pwm_l3) = pwm;
              ESP_LOGI("custom", "Kézi 3F pwm=%.2f", pwm);
            }

            return;
          }

          // ------------------------------------------------------------------
          // Ha semmi sem aktiválta a PWM-et (biztonsági fallback)
          // ------------------------------------------------------------------
          id(pwm_output1).set_level(0.0);
          id(pwm_output2).set_level(0.0);
          id(pwm_output3).set_level(0.0);
          id(pwm_l1) = 0.0;
          id(pwm_l2) = 0.0;
          id(pwm_l3) = 0.0;
          ESP_LOGW("custom", "Nem felelt meg egyik feltétel sem – PWM=0");

interval:
  - id: mk1
    interval: 5s
    then: 
      - lambda: |-
          if ((id(maxt).state > id(hmvh).state) &&
              (id(st).state == 1 ) &&
              (id(en_switch).state == 1 )) {

            id(rele1).turn_on();

          } else {
            id(rele1).turn_off();
          }

  - id: mk2
    interval: 1s
    then:
      - lambda: |-
          if (id(pwm_l1) > 0.0 || id(pwm_l2) > 0.0 || id(pwm_l3) > 0.0) {
            id(rele2).turn_on();
            ESP_LOGW("custom", "MK2 BE");
          } else {
            id(rele2).turn_off();
          }
          
output:
  - platform: ledc
    id: pwm_output1
    pin: GPIO5
    inverted: True
    frequency: "50Hz"
    max_power: 0.98

  - platform: ledc
    id: pwm_output2
    pin: GPIO38
    inverted: True
    frequency: "50Hz"
    max_power: 0.98

  - platform: ledc
    id: pwm_output3
    pin: GPIO6
    inverted: True
    frequency: "50Hz"
    max_power: 0.98
  
  - platform: gpio
    id: rele1
    pin: GPIO40

  - platform: gpio
    id: rele2
    pin: GPIO39
